### Лабораторная работа по С# №4

```
Демин Мефодий, ИТ-12, 2024
```

---

## Задача 1: Замена вхождения в List

### Условие:
Составить программу, которая в списке L заменяет первое вхождение списка L1 (если такое есть) на список L2.

### Алгоритм решения:
1. **Ввод данных**: Пользователь вводит три списка целых чисел через пробел
2. **Преобразование**: Строки преобразуются в `List<int>`
3. **Поиск вхождения**: 
   - Последовательный перебор элементов списка L
   - Поиск позиции, где начинается список L1
   - Использование двойного цикла для сравнения элементов
4. **Замена**:
   - Если L1 найден - удаление элементов L1 из L
   - Вставка элементов L2 на позицию найденного вхождения
5. **Вывод результата**: Отображение исходных данных и результата операции

### Используемые структуры данных:
- `List<int>` - для хранения и модификации последовательностей

---

## Задача 2: Сортировка LinkedList

### Условие:
Отсортировать элементы связного списка по возрастанию.

### Алгоритм решения:
1. **Ввод данных**: Пользователь вводит элементы связного списка
2. **Создание структуры**: Числа добавляются в `LinkedList<int>`
3. **Сортировка пузырьком**:
   - Многократные проходы по списку
   - Сравнение соседних элементов через `LinkedListNode<T>`
   - Обмен значений при неправильном порядке
   - Продолжение пока есть перестановки
4. **Визуализация**: Отображение списка после каждого прохода
5. **Вывод результата**: Показ отсортированного списка

### Используемые структуры данных:
- `LinkedList<int>` - для работы со связным списком
- `LinkedListNode<int>` - для доступа к узлам списка

---

## Задача 3: Анализ игр студентов (HashSet)

### Условие:
Есть перечень компьютерных игр. Студенты группы играют в какие-либо из этих игр. Определить:
- В какие игры из перечня играют все студенты группы
- В какие игры из перечня играют некоторые студенты группы  
- В какие игры из перечня не играет ни один из студентов группы

### Алгоритм решения:
1. **Инициализация данных**:
   - Создание фиксированного перечня игр в `HashSet<string>`
   - Использование `Dictionary<string, HashSet<string>>` для хранения студентов и их игр

2. **Интерактивный ввод**:
   - Добавление студентов с уникальными фамилиями
   - Выбор игр из доступного перечня для каждого студента
   - Проверка валидности вводимых данных

3. **Анализ данных**:
   - **Общие игры**: `IntersectWith()` - пересечение множеств игр всех студентов
   - **Игры некоторых**: `UnionWith()` - объединение множеств игр студентов
   - **Игры без игроков**: `ExceptWith()` - разность общего перечня и игр студентов

4. **Детальная информация**:
   - Для каждой игры определение списка игроков
   - Статистика по количеству студентов, игр и игроков

### Используемые структуры данных:
- `HashSet<string>` - для хранения множеств игр
- `Dictionary<string, HashSet<string>>` - для связи студент→игры

---

## Задача 4: Глухие согласные из файла (HashSet)

### Условие:
Файл содержит текст на русском языке. Напечатать в алфавитном порядке все глухие согласные буквы, которые не входят хотя бы в одно слово.

### Алгоритм решения:
1. **Чтение файла**: Загрузка текста из файла `text.txt`
2. **Предобработка текста**:
   - Приведение к нижнему регистру
   - Разделение на слова с удалением знаков препинания
3. **Работа с согласными**:
   - Создание `HashSet<char>` с глухими согласными русского языка
   - Для каждой согласной проверка присутствия во всех словах
4. **Формирование результата**:
   - Сбор согласных, отсутствующих хотя бы в одном слове
   - Сортировка результата в алфавитном порядке
5. **Детальный анализ**: Показ присутствия каждой согласной в словах

### Используемые структуры данных:
- `HashSet<char>` - для хранения множества согласных
- `string[]` - для хранения слов текста

---

## Задача 5: Результаты олимпиады (Dictionary)

### Условие:
На городской олимпиаде по информатике участникам было предложено выполнить 3 задания, каждое из которых оценивалось по 25-балльной шкале. Известны результаты участников. Найти и вывести участников, набравших максимальное количество баллов.

### Алгоритм решения:
1. **Чтение данных**: Загрузка информации из файла `olympiad.txt`
2. **Парсинг данных**:
   - Разбор строк на фамилию, имя и баллы
   - Вычисление общей суммы баллов за три задания
3. **Хранение данных**: Использование `Dictionary<string, int>` для связи участник→баллы
4. **Поиск победителей**:
   - Определение максимального балла
   - Поиск всех участников с максимальным баллом
5. **Сортировка результатов**: Вывод всех участников в порядке убывания баллов

### Используемые структуры данных:
- `Dictionary<string, int>` - для хранения участников и их баллов
- `List<KeyValuePair<string, int>>` - для сортировки результатов
  
---

### Реализация класса для работы с денежными суммами в рублях и копейках с поддержкой основных арифметических операций и операций преобразования.

### Задание 6
**Класс**: Money  
**Поля**: 
- `uint rubles` - рубли
- `byte kopeks` - копейки

**Методы**:
- Конструкторы (по умолчанию, с параметрами, копирования)
- `ToString()` - вывод полей в формате "X руб. YY коп."
- `AddKopeks(uint kopeksToAdd)` - добавление произвольного количества копеек к объекту типа Money

### Задание 7
**Унарные операции**:
- `++` - добавление одной копейки к объекту типа Money
- `--` - вычитание одной копейки из объекта типа Money

**Операции приведения типа**:
- `(uint)` (явная) - результатом является количество рублей (копейки отбрасываются)
- `(double)` (неявная) - результатом являются копейки, переведенные в рубли

**Бинарные операции**:
- `+` - сложение Money и беззнакового целого числа (лево- и правосторонние)
- `-` - вычитание Money и беззнакового целого числа (лево- и правосторонние)

## Алгоритм решения

### Структура класса Money

**Поля и свойства**:
- Приватные поля `_rubles` (uint) и `_kopeks` (byte)
- Публичные свойства с валидацией (копейки не могут быть ≥ 100)

**Конструкторы**:
- Конструктор с параметрами (рубли, копейки)
- Конструктор по умолчанию (0 руб. 0 коп.)
- Конструктор копирования

**Основной метод AddKopeks**:
1. Конвертация всей суммы в копейки: `totalKopeks = rubles * 100 + kopeks + kopeksToAdd`
2. Вычисление новых значений: 
   - `newRubles = totalKopeks / 100`
   - `newKopeks = totalKopeks % 100`
3. Проверка переполнения
4. Возврат нового объекта Money

**Унарные операторы**:
- `++` - вызывает `AddKopeks(1)`
- `--` - вычитает 1 копейку с проверкой на отрицательный результат

**Операторы приведения**:
- `(uint)` - возвращает только рубли
- `(double)` - возвращает копейки в долях рублей

**Бинарные операторы**:
- `+` - использует метод `AddKopeks`
- `-` - вычитает указанное количество копеек с проверкой на отрицательный результат

